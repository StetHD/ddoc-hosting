<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset = "utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <meta http-equiv="x-ua-compatible" content="ie=edge">

        <title>Dottydoc - ShortcutImplicits</title>

        <script type="text/javascript" src="../../docassets/material.min.js"></script>
        <script type="text/javascript" src="../../docassets/highlight.pack.js"></script>
        <script type="text/javascript" src="../../docassets/index.js"></script>
        <script type="text/javascript" src="../../docassets/dottydoc.js"></script>
        <link rel="stylesheet" href="../../docassets/material-icons.css">
        <link rel="stylesheet" href="../../docassets/material.min.css">
        <link rel="stylesheet" href="../../docassets/github.css">
        <link rel="stylesheet" href="../../docassets/index.css">
    </head>
    <body>
        <div id="main-container">
            <script>
                Index.currentEntity = {"name":"ShortcutImplicits","members":[{"name":"Transform","members":[{"name":"directInfo","modifiers":["private"],"path":["dotty","tools","dotc","transform","ShortcutImplicits","Transform","directInfo"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"info","ref":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"","short":"","authors":[],"see":[],"result":"<p>The type of the <code>apply</code> member of <code>implicit Ts => R</code>.</p>","throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"directMeth","modifiers":["private"],"path":["dotty","tools","dotc","transform","ShortcutImplicits","Transform","directMeth"],"returnValue":{"title":"HashMap","tpeLink":{"title":"HashMap","target":"scala.collection.mutable.HashMap","kind":"NoLink"},"paramLinks":[{"title":"Symbol","tpeLink":{"title":"Symbol","target":"scala.Symbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},{"title":"Symbol","tpeLink":{"title":"Symbol","target":"scala.Symbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"comment":{"body":"<p>A map to cache mapping local methods to their direct counterparts.\n A fresh map is created for each unit.\n</p>","short":"<p>A map to cache mapping local methods to their direct counterparts.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"val"},{"name":"directMethod","modifiers":["private"],"path":["dotty","tools","dotc","transform","ShortcutImplicits","Transform","directMethod"],"returnValue":{"title":"Symbol","tpeLink":{"title":"Symbol","target":"scala.Symbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"sym","ref":{"title":"Symbol","tpeLink":{"title":"Symbol","target":"scala.Symbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>The direct method <code>m$direct</code> that accompanies the given method <code>m</code>.\n Create one if it does not exist already.\n</p>","short":"<p>The direct method <code>m$direct</code> that accompanies the given method <code>m</code>.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"newDirectMethod","modifiers":["private"],"path":["dotty","tools","dotc","transform","ShortcutImplicits","Transform","newDirectMethod"],"returnValue":{"title":"Symbol","tpeLink":{"title":"Symbol","target":"scala.Symbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"sym","ref":{"title":"Symbol","tpeLink":{"title":"Symbol","target":"scala.Symbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>A new <code>m$direct</code> method to accompany the given method <code>m</code></p>","short":"<p>A new <code>m$direct</code> method to accompany the given method <code>m</code></p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"phase","modifiers":[],"path":["dotty","tools","dotc","transform","ShortcutImplicits","Transform","phase"],"returnValue":{"title":"MiniPhase","tpeLink":{"title":"MiniPhase","target":"scala.MiniPhase","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[],"kind":"def"},{"name":"prepareForUnit","modifiers":["override"],"path":["dotty","tools","dotc","transform","ShortcutImplicits","Transform","prepareForUnit"],"returnValue":{"title":"TreeTransform","tpeLink":{"title":"TreeTransform","target":"scala.TreeTransform","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"tree","ref":{"title":"Tree","tpeLink":{"title":"Tree","target":"scala.Tree","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"kind":"def"},{"name":"shouldBeSpecialized","modifiers":["private"],"path":["dotty","tools","dotc","transform","ShortcutImplicits","Transform","shouldBeSpecialized"],"returnValue":{"title":"Boolean","tpeLink":{"title":"Boolean","target":"scala.Boolean","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"sym","ref":{"title":"Symbol","tpeLink":{"title":"Symbol","target":"scala.Symbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>Should <code>sym</code> get a ..$direct companion?\n This is the case if (1) <code>sym</code> is a method with an implicit function type as final result type.\n However if <code>specializeMonoTargets</code> is false, we exclude symbols that are known\n to be only targets of monomorphic calls because they are effectively\n final and don't override anything.\n</p>","short":"<p>Should <code>sym</code> get a ..$direct companion?\n This is the case if (1) <code>sym</code> is a method with an implicit function type as final result type.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"transformDefDef","modifiers":["override"],"path":["dotty","tools","dotc","transform","ShortcutImplicits","Transform","transformDefDef"],"returnValue":{"title":"Tree","tpeLink":{"title":"Tree","target":"scala.Tree","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"mdef","ref":{"title":"DefDef","tpeLink":{"title":"DefDef","target":"scala.DefDef","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"info","ref":{"title":"TransformerInfo","tpeLink":{"title":"TransformerInfo","target":"scala.TransformerInfo","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>Transform methods with implicit function type result according to rewrite rule (1) above</p>","short":"<p>Transform methods with implicit function type result according to rewrite rule (1) above</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"transformSelect","modifiers":["override"],"path":["dotty","tools","dotc","transform","ShortcutImplicits","Transform","transformSelect"],"returnValue":{"title":"Tree","tpeLink":{"title":"Tree","target":"scala.Tree","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"tree","ref":{"title":"Select","tpeLink":{"title":"Select","target":"scala.Select","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"info","ref":{"title":"TransformerInfo","tpeLink":{"title":"TransformerInfo","target":"scala.TransformerInfo","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>Transform <code>qual.apply</code> occurrences according to rewrite rule (2) above</p>","short":"<p>Transform <code>qual.apply</code> occurrences according to rewrite rule (2) above</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"}],"modifiers":[],"path":["dotc","transform","Transform"],"typeParams":[],"constructors":[[{"list":[],"isImplicit":false}]],"superTypes":[{"title":"TreeTransform","target":"dotty.tools.dotc.transform.TreeTransforms$.TreeTransform","kind":"NoLink"}],"kind":"class"},{"name":"phaseName","modifiers":["override"],"path":["dotty","tools","dotc","transform","ShortcutImplicits","phaseName"],"returnValue":{"title":"String","tpeLink":{"title":"String","target":"scala.String","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[],"kind":"def"},{"name":"specializeMonoTargets","modifiers":["final"],"path":["dotty","tools","dotc","transform","ShortcutImplicits","specializeMonoTargets"],"returnValue":{"title":"Boolean(true)","kind": "ConstantReference"},"comment":{"body":"<p>If this option is true, we don't specialize symbols that are known to be only\n targets of monomorphic calls.\n The reason for this option is that benchmarks show that on the JVM for monomorphic dispatch\n scenarios inlining and escape analysis can often remove all calling overhead, so we might as\n well not duplicate the code. We need more experience to decide on the best setting of this option.\n</p>","short":"<p>If this option is true, we don't specialize symbols that are known to be only\n targets of monomorphic calls.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"val"},{"name":"treeTransform","modifiers":[],"path":["dotty","tools","dotc","transform","ShortcutImplicits","treeTransform"],"returnValue":{"title":"TreeTransform","tpeLink":{"title":"TreeTransform","target":"scala.TreeTransform","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"kind":"val"}],"modifiers":[],"path":["dotc","transform","ShortcutImplicits"],"typeParams":[],"constructors":[[{"list":[],"isImplicit":false}]],"superTypes":[{"title":"DotClass","target":"dotty.tools.dotc.util.DotClass","kind":"NoLink"},{"title":"MiniPhase","target":"dotty.tools.dotc.transform.TreeTransforms$.MiniPhase","kind":"NoLink"},{"title":"IdentityDenotTransformer","target":"dotty.tools.dotc.core.DenotTransformers$.IdentityDenotTransformer","kind":"NoLink"}],"comment":{"body":"<p>This phase optimizes code using implicit function types, by applying two rewrite rules.\n Let IF be the implicit function type</p><p>     implicit Us => R</p><p> (1) A method definition</p><p>     def m(xs: Ts): IF = implicit (ys: Us) => E</p><p> is expanded to two methods:</p><p>     def m(xs: Ts): IF = implicit (ys: Us) => m$direct(xs)(ys)\n     def m$direct(xs: Ts)(ys: Us): R = E</p><p> (and equivalently for methods with type parameters or a different number of value parameter lists).\n An abstract method definition</p><p>    def m(xs: Ts): IF</p><p> is expanded to:</p><p>    def m(xs: Ts): IF\n    def m$direct(xs: Ts)(ys: Us): R</p><p> (2) A reference <code>qual.apply</code> where <code>qual</code> has implicit function type and\n <code>qual</code> refers to a method <code>m</code> is rewritten to a reference to <code>m$direct</code>,\n keeping the same type and value arguments as they are found in <code>qual</code>.\n</p>","short":"<p>This phase optimizes code using implicit function types, by applying two rewrite rules.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"class"};
                dotty.tools.doc.client.DottyDoc().main(document.getElementById("main-container"));
            </script>
        </div>
    </body>
</html>
