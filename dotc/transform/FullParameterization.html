<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset = "utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <meta http-equiv="x-ua-compatible" content="ie=edge">

        <title>Dottydoc - FullParameterization</title>

        <script type="text/javascript" src="../../docassets/material.min.js"></script>
        <script type="text/javascript" src="../../docassets/highlight.pack.js"></script>
        <script type="text/javascript" src="../../docassets/index.js"></script>
        <script type="text/javascript" src="../../docassets/dottydoc.js"></script>
        <link rel="stylesheet" href="../../docassets/material-icons.css">
        <link rel="stylesheet" href="../../docassets/material.min.css">
        <link rel="stylesheet" href="../../docassets/github.css">
        <link rel="stylesheet" href="../../docassets/index.css">
    </head>
    <body>
        <div id="main-container">
            <script>
                Index.currentEntity = {"name":"FullParameterization","members":[{"name":"allInstanceTypeParams","modifiers":["private"],"path":["dotty","tools","dotc","transform","FullParameterization","allInstanceTypeParams"],"returnValue":{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"Symbol","tpeLink":{"title":"Symbol","target":"scala.Symbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"originalDef","ref":{"title":"DefDef","tpeLink":{"title":"DefDef","target":"scala.DefDef","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"abstractOverClass","ref":{"title":"Boolean","tpeLink":{"title":"Boolean","target":"scala.Boolean","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>The type parameters (skolems) of the method definition <code>originalDef</code>,\n followed by the class parameters of its enclosing class.\n</p>","short":"<p>The type parameters (skolems) of the method definition <code>originalDef</code>,\n followed by the class parameters of its enclosing class.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"forwarder","modifiers":[],"path":["dotty","tools","dotc","transform","FullParameterization","forwarder"],"returnValue":{"title":"Tree","tpeLink":{"title":"Tree","target":"scala.Tree","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"derived","ref":{"title":"TermSymbol","tpeLink":{"title":"TermSymbol","target":"scala.TermSymbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"originalDef","ref":{"title":"DefDef","tpeLink":{"title":"DefDef","target":"scala.DefDef","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"abstractOverClass","ref":{"title":"Boolean","tpeLink":{"title":"Boolean","target":"scala.Boolean","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"liftThisType","ref":{"title":"Boolean","tpeLink":{"title":"Boolean","target":"scala.Boolean","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>A forwarder expression which calls <code>derived</code>, passing along</p><ul><li>if <code>abstractOverClass</code> the type parameters and enclosing class parameters of originalDef<code>,</code></li><li>the <code>this</code> of the enclosing class,</li><li>the value parameters of the original method <code>originalDef</code>.\n</li></ul>","short":"<p>A forwarder expression which calls <code>derived</code>, passing along</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"forwarder$default$3","modifiers":[],"path":["dotty","tools","dotc","transform","FullParameterization","forwarder$default$3"],"returnValue":{"title":"Boolean","tpeLink":{"title":"Boolean","target":"scala.Boolean","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[],"comment":{"body":"<p>A forwarder expression which calls <code>derived</code>, passing along</p><ul><li>if <code>abstractOverClass</code> the type parameters and enclosing class parameters of originalDef<code>,</code></li><li>the <code>this</code> of the enclosing class,</li><li>the value parameters of the original method <code>originalDef</code>.\n</li></ul>","short":"<p>A forwarder expression which calls <code>derived</code>, passing along</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"forwarder$default$4","modifiers":[],"path":["dotty","tools","dotc","transform","FullParameterization","forwarder$default$4"],"returnValue":{"title":"Boolean","tpeLink":{"title":"Boolean","target":"scala.Boolean","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[],"comment":{"body":"<p>A forwarder expression which calls <code>derived</code>, passing along</p><ul><li>if <code>abstractOverClass</code> the type parameters and enclosing class parameters of originalDef<code>,</code></li><li>the <code>this</code> of the enclosing class,</li><li>the value parameters of the original method <code>originalDef</code>.\n</li></ul>","short":"<p>A forwarder expression which calls <code>derived</code>, passing along</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"fullyParameterizedDef","modifiers":[],"path":["dotty","tools","dotc","transform","FullParameterization","fullyParameterizedDef"],"returnValue":{"title":"Tree","tpeLink":{"title":"Tree","target":"scala.Tree","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"derived","ref":{"title":"TermSymbol","tpeLink":{"title":"TermSymbol","target":"scala.TermSymbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"originalDef","ref":{"title":"DefDef","tpeLink":{"title":"DefDef","target":"scala.DefDef","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"abstractOverClass","ref":{"title":"Boolean","tpeLink":{"title":"Boolean","target":"scala.Boolean","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>Given an instance method definition <code>originalDef</code>, return a\n fully parameterized method definition derived from <code>originalDef</code>, which\n has <code>derived</code> as symbol and <code>fullyParameterizedType(originalDef.symbol.info)</code>\n as info.\n <code>abstractOverClass</code> defines weather the DefDef should abstract over type parameters\n of class that contained original defDef\n</p>","short":"<p>Given an instance method definition <code>originalDef</code>, return a\n fully parameterized method definition derived from <code>originalDef</code>, which\n has <code>derived</code> as symbol and <code>fullyParameterizedType(originalDef.symbol.info)</code>\n as info.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"fullyParameterizedDef$default$3","modifiers":[],"path":["dotty","tools","dotc","transform","FullParameterization","fullyParameterizedDef$default$3"],"returnValue":{"title":"Boolean","tpeLink":{"title":"Boolean","target":"scala.Boolean","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[],"comment":{"body":"<p>Given an instance method definition <code>originalDef</code>, return a\n fully parameterized method definition derived from <code>originalDef</code>, which\n has <code>derived</code> as symbol and <code>fullyParameterizedType(originalDef.symbol.info)</code>\n as info.\n <code>abstractOverClass</code> defines weather the DefDef should abstract over type parameters\n of class that contained original defDef\n</p>","short":"<p>Given an instance method definition <code>originalDef</code>, return a\n fully parameterized method definition derived from <code>originalDef</code>, which\n has <code>derived</code> as symbol and <code>fullyParameterizedType(originalDef.symbol.info)</code>\n as info.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"fullyParameterizedType","modifiers":[],"path":["dotty","tools","dotc","transform","FullParameterization","fullyParameterizedType"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"info","ref":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"clazz","ref":{"title":"ClassSymbol","tpeLink":{"title":"ClassSymbol","target":"scala.ClassSymbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"abstractOverClass","ref":{"title":"Boolean","tpeLink":{"title":"Boolean","target":"scala.Boolean","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"liftThisType","ref":{"title":"Boolean","tpeLink":{"title":"Boolean","target":"scala.Boolean","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>Converts the type <code>info</code> of a member of class <code>clazz</code> to a method type that\n takes the <code>this</code> of the class and any type parameters of the class\n as additional parameters. Example:</p><p>   class Foo[+A <: AnyRef](val xs: List[A]) extends AnyVal {\n     def baz[B >: A](x: B): List[B] = ...\n   }</p><p> leads to:</p><p>   object Foo {\n     def extension$baz[B >: A <: Any, A >: Nothing <: AnyRef]($this: Foo[A])(x: B): List[B]\n   }</p><p> If a self type is present, $this has this self type as its type.\n</p>","short":"<p>Converts the type <code>info</code> of a member of class <code>clazz</code> to a method type that\n takes the <code>this</code> of the class and any type parameters of the class\n as additional parameters.</p>","authors":[],"see":[],"throws":{},"valueParams":{"abstractOverClass":"<p>if true, include the type parameters of the class in the method's list of type parameters.</p>","liftThisType":"<p>if true, require created $this to be $this: (Foo[A] & Foo,this).\n                           This is needed if created member stays inside scope of Foo(as in tailrec)</p>"},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"fullyParameterizedType$default$3","modifiers":[],"path":["dotty","tools","dotc","transform","FullParameterization","fullyParameterizedType$default$3"],"returnValue":{"title":"Boolean","tpeLink":{"title":"Boolean","target":"scala.Boolean","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[],"comment":{"body":"<p>Converts the type <code>info</code> of a member of class <code>clazz</code> to a method type that\n takes the <code>this</code> of the class and any type parameters of the class\n as additional parameters. Example:</p><p>   class Foo[+A <: AnyRef](val xs: List[A]) extends AnyVal {\n     def baz[B >: A](x: B): List[B] = ...\n   }</p><p> leads to:</p><p>   object Foo {\n     def extension$baz[B >: A <: Any, A >: Nothing <: AnyRef]($this: Foo[A])(x: B): List[B]\n   }</p><p> If a self type is present, $this has this self type as its type.\n</p>","short":"<p>Converts the type <code>info</code> of a member of class <code>clazz</code> to a method type that\n takes the <code>this</code> of the class and any type parameters of the class\n as additional parameters.</p>","authors":[],"see":[],"throws":{},"valueParams":{"abstractOverClass":"<p>if true, include the type parameters of the class in the method's list of type parameters.</p>","liftThisType":"<p>if true, require created $this to be $this: (Foo[A] & Foo,this).\n                           This is needed if created member stays inside scope of Foo(as in tailrec)</p>"},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"fullyParameterizedType$default$4","modifiers":[],"path":["dotty","tools","dotc","transform","FullParameterization","fullyParameterizedType$default$4"],"returnValue":{"title":"Boolean","tpeLink":{"title":"Boolean","target":"scala.Boolean","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[],"comment":{"body":"<p>Converts the type <code>info</code> of a member of class <code>clazz</code> to a method type that\n takes the <code>this</code> of the class and any type parameters of the class\n as additional parameters. Example:</p><p>   class Foo[+A <: AnyRef](val xs: List[A]) extends AnyVal {\n     def baz[B >: A](x: B): List[B] = ...\n   }</p><p> leads to:</p><p>   object Foo {\n     def extension$baz[B >: A <: Any, A >: Nothing <: AnyRef]($this: Foo[A])(x: B): List[B]\n   }</p><p> If a self type is present, $this has this self type as its type.\n</p>","short":"<p>Converts the type <code>info</code> of a member of class <code>clazz</code> to a method type that\n takes the <code>this</code> of the class and any type parameters of the class\n as additional parameters.</p>","authors":[],"see":[],"throws":{},"valueParams":{"abstractOverClass":"<p>if true, include the type parameters of the class in the method's list of type parameters.</p>","liftThisType":"<p>if true, require created $this to be $this: (Foo[A] & Foo,this).\n                           This is needed if created member stays inside scope of Foo(as in tailrec)</p>"},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"rewiredTarget","modifiers":["protected"],"path":["dotty","tools","dotc","transform","FullParameterization","rewiredTarget"],"returnValue":{"title":"Symbol","tpeLink":{"title":"Symbol","target":"scala.Symbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"referenced","ref":{"title":"Symbol","tpeLink":{"title":"Symbol","target":"scala.Symbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"derived","ref":{"title":"Symbol","tpeLink":{"title":"Symbol","target":"scala.Symbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>If references to original symbol <code>referenced</code> from within fully parameterized method\n <code>derived</code> should be rewired to some fully parameterized method, the rewiring target symbol,\n otherwise NoSymbol.\n</p>","short":"<p>If references to original symbol <code>referenced</code> from within fully parameterized method\n <code>derived</code> should be rewired to some fully parameterized method, the rewiring target symbol,\n otherwise NoSymbol.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"rewiredTarget","modifiers":["protected"],"path":["dotty","tools","dotc","transform","FullParameterization","rewiredTarget"],"returnValue":{"title":"Symbol","tpeLink":{"title":"Symbol","target":"scala.Symbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"tree","ref":{"title":"Tree","tpeLink":{"title":"Tree","target":"scala.Tree","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"derived","ref":{"title":"Symbol","tpeLink":{"title":"Symbol","target":"scala.Symbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>If references to some original symbol from given tree node within fully parameterized method\n <code>derived</code> should be rewired to some fully parameterized method, the rewiring target symbol,\n otherwise NoSymbol. By default implemented as</p><p>     rewiredTarget(tree.symbol, derived)</p><p> but can be overridden.\n</p>","short":"<p>If references to some original symbol from given tree node within fully parameterized method\n <code>derived</code> should be rewired to some fully parameterized method, the rewiring target symbol,\n otherwise NoSymbol.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"}],"modifiers":[],"path":["dotc","transform","FullParameterization"],"typeParams":[],"traitParams":[{"list":[],"isImplicit":false}],"superTypes":[],"comment":{"body":"<p>Provides methods to produce fully parameterized versions of instance methods,\n where the <code>this</code> of the enclosing class is abstracted out in an extra leading\n <code>$this</code> parameter and type parameters of the class become additional type\n parameters of the fully parameterized method.</p><p> Example usage scenarios are:</p><ul><li>extension methods of value classes</li><li>implementations of trait methods</li><li>static protected accessors</li><li>local methods produced by tailrec transform</li></ul><p> Note that the methods lift out type parameters of the class containing\n the instance method, but not type parameters of enclosing classes. The\n fully instantiated method therefore needs to be put in a scope \"close\"\n to the original method, i.e. they need to share the same outer pointer.\n Examples of legal positions are: in the companion object, or as a local\n method inside the original method.</p><p> Note: The scheme does not handle yet methods where type parameter bounds\n depend on value parameters of the enclosing class, as in:</p><p>     class C(val a: String) extends AnyVal {\n       def foo[U <: a.type]: Unit = ...\n     }</p><p> The expansion of method <code>foo</code> would lead to</p><p>     def foo$extension[U <: $this.a.type]($this: C): Unit = ...</p><p> which is not typable. Not clear yet what to do. Maybe allow PolyTypes\n to follow method parameters and translate to the following:</p><p>     def foo$extension($this: C)[U <: $this.a.type]: Unit = ...\n</p>","short":"<p>Provides methods to produce fully parameterized versions of instance methods,\n where the <code>this</code> of the enclosing class is abstracted out in an extra leading\n <code>$this</code> parameter and type parameters of the class become additional type\n parameters of the fully parameterized method.</p>","authors":[],"see":["<p>class-dependent-extension-method.scala in pending/pos.</p>"],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"trait"};
                dotty.tools.doc.client.DottyDoc().main(document.getElementById("main-container"));
            </script>
        </div>
    </body>
</html>
