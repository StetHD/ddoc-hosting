<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset = "utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <meta http-equiv="x-ua-compatible" content="ie=edge">

        <title>Dottydoc - NavigateAST</title>

        <script type="text/javascript" src="../../docassets/material.min.js"></script>
        <script type="text/javascript" src="../../docassets/highlight.pack.js"></script>
        <script type="text/javascript" src="../../docassets/index.js"></script>
        <script type="text/javascript" src="../../docassets/dottydoc.js"></script>
        <link rel="stylesheet" href="../../docassets/material-icons.css">
        <link rel="stylesheet" href="../../docassets/material.min.css">
        <link rel="stylesheet" href="../../docassets/github.css">
        <link rel="stylesheet" href="../../docassets/index.css">
    </head>
    <body>
        <div id="main-container">
            <script>
                Index.currentEntity = {"name":"NavigateAST","members":[{"name":"pathTo","modifiers":[],"path":["dotty","tools","dotc","ast","NavigateAST$","pathTo"],"returnValue":{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"Positioned","tpeLink":{"title":"Positioned","target":"scala.Positioned","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"pos","ref":{"title":"Position","tpeLink":{"title":"Position","target":"scala.Position","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"from","ref":{"title":"Positioned","tpeLink":{"title":"Positioned","target":"scala.Positioned","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>The reverse path from node <code>from</code> to the node that closest encloses position <code>pos</code>,\n or <code>Nil</code> if no such path exists. If a non-empty path is returned it starts with\n the node closest enclosing <code>pos</code> and ends with <code>from</code>.\n</p>","short":"<p>The reverse path from node <code>from</code> to the node that closest encloses position <code>pos</code>,\n or <code>Nil</code> if no such path exists.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"toUntyped","modifiers":[],"path":["dotty","tools","dotc","ast","NavigateAST$","toUntyped"],"returnValue":{"title":"Tree","tpeLink":{"title":"Tree","target":"scala.Tree","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"tree","ref":{"title":"Tree","tpeLink":{"title":"Tree","target":"scala.Tree","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>The untyped tree corresponding to typed tree <code>tree</code> in the compilation\n unit specified by <code>ctx</code>\n</p>","short":"<p>The untyped tree corresponding to typed tree <code>tree</code> in the compilation\n unit specified by <code>ctx</code>\n</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"untypedPath","modifiers":[],"path":["dotty","tools","dotc","ast","NavigateAST$","untypedPath"],"returnValue":{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"Positioned","tpeLink":{"title":"Positioned","target":"scala.Positioned","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"tree","ref":{"title":"Tree","tpeLink":{"title":"Tree","target":"scala.Tree","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"exactMatch","ref":{"title":"Boolean","tpeLink":{"title":"Boolean","target":"scala.Boolean","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>The reverse path of untyped trees starting with a tree that closest matches\n <code>tree</code> and ending in the untyped tree at the root of the compilation unit\n specified by <code>ctx</code>.</p>","short":"<p>The reverse path of untyped trees starting with a tree that closest matches\n <code>tree</code> and ending in the untyped tree at the root of the compilation unit\n specified by <code>ctx</code>.</p>","authors":[],"see":[],"throws":{},"valueParams":{"exactMatch":"<p>If <code>true</code>, the path must start with a node that exactly\n                      matches <code>tree</code>, or <code>Nil</code> is returned.\n                      If <code>false</code> the path might start with a node enclosing\n                      the logical position of <code>tree</code>.\n Note: A complication concerns member definitions. ValDefs and DefDefs\n have after desugaring a position that spans just the name of the symbol being\n defined and nothing else. So we look instead for an untyped tree approximating the\n envelope of the definition, and declare success if we find another DefTree.</p>"},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"untypedPath","modifiers":[],"path":["dotty","tools","dotc","ast","NavigateAST$","untypedPath"],"returnValue":{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"Positioned","tpeLink":{"title":"Positioned","target":"scala.Positioned","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"pos","ref":{"title":"Position","tpeLink":{"title":"Position","target":"scala.Position","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>The reverse part of the untyped root of the compilation unit of <code>ctx</code> to\n position <code>pos</code>.\n</p>","short":"<p>The reverse part of the untyped root of the compilation unit of <code>ctx</code> to\n position <code>pos</code>.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"untypedPath$default$2","modifiers":[],"path":["dotty","tools","dotc","ast","NavigateAST$","untypedPath$default$2"],"returnValue":{"title":"Boolean","tpeLink":{"title":"Boolean","target":"scala.Boolean","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[],"comment":{"body":"<p>The reverse path of untyped trees starting with a tree that closest matches\n <code>tree</code> and ending in the untyped tree at the root of the compilation unit\n specified by <code>ctx</code>.</p>","short":"<p>The reverse path of untyped trees starting with a tree that closest matches\n <code>tree</code> and ending in the untyped tree at the root of the compilation unit\n specified by <code>ctx</code>.</p>","authors":[],"see":[],"throws":{},"valueParams":{"exactMatch":"<p>If <code>true</code>, the path must start with a node that exactly\n                      matches <code>tree</code>, or <code>Nil</code> is returned.\n                      If <code>false</code> the path might start with a node enclosing\n                      the logical position of <code>tree</code>.\n Note: A complication concerns member definitions. ValDefs and DefDefs\n have after desugaring a position that spans just the name of the symbol being\n defined and nothing else. So we look instead for an untyped tree approximating the\n envelope of the definition, and declare success if we find another DefTree.</p>"},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"}],"modifiers":["final"],"path":["dotc","ast","NavigateAST$"],"superTypes":[],"comment":{"body":"<p>Utility functions to go from typed to untyped ASTs</p>","short":"<p>Utility functions to go from typed to untyped ASTs</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"object"};
                dotty.tools.doc.client.DottyDoc().main(document.getElementById("main-container"));
            </script>
        </div>
    </body>
</html>
