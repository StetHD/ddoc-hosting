<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset = "utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <meta http-equiv="x-ua-compatible" content="ie=edge">

        <title>Dottydoc - dotc.ast</title>

        <script type="text/javascript" src="../../docassets/material.min.js"></script>
        <script type="text/javascript" src="../../docassets/highlight.pack.js"></script>
        <script type="text/javascript" src="../../docassets/index.js"></script>
        <script type="text/javascript" src="../../docassets/dottydoc.js"></script>
        <link rel="stylesheet" href="../../docassets/material-icons.css">
        <link rel="stylesheet" href="../../docassets/material.min.css">
        <link rel="stylesheet" href="../../docassets/github.css">
        <link rel="stylesheet" href="../../docassets/index.css">
    </head>
    <body>
        <div id="main-container">
            <script>
                Index.currentEntity = {"name":"dotc.ast","members":[{"name":"NavigateAST","members":[{"name":"pathTo","modifiers":[],"path":["dotty","tools","dotc","ast","NavigateAST$","pathTo"],"returnValue":{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"Positioned","tpeLink":{"title":"Positioned","target":"scala.Positioned","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"pos","ref":{"title":"Position","tpeLink":{"title":"Position","target":"scala.Position","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"from","ref":{"title":"Positioned","tpeLink":{"title":"Positioned","target":"scala.Positioned","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>The reverse path from node <code>from</code> to the node that closest encloses position <code>pos</code>,\n or <code>Nil</code> if no such path exists. If a non-empty path is returned it starts with\n the node closest enclosing <code>pos</code> and ends with <code>from</code>.\n</p>","short":"<p>The reverse path from node <code>from</code> to the node that closest encloses position <code>pos</code>,\n or <code>Nil</code> if no such path exists.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"toUntyped","modifiers":[],"path":["dotty","tools","dotc","ast","NavigateAST$","toUntyped"],"returnValue":{"title":"Tree","tpeLink":{"title":"Tree","target":"scala.Tree","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"tree","ref":{"title":"Tree","tpeLink":{"title":"Tree","target":"scala.Tree","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>The untyped tree corresponding to typed tree <code>tree</code> in the compilation\n unit specified by <code>ctx</code>\n</p>","short":"<p>The untyped tree corresponding to typed tree <code>tree</code> in the compilation\n unit specified by <code>ctx</code>\n</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"untypedPath","modifiers":[],"path":["dotty","tools","dotc","ast","NavigateAST$","untypedPath"],"returnValue":{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"Positioned","tpeLink":{"title":"Positioned","target":"scala.Positioned","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"tree","ref":{"title":"Tree","tpeLink":{"title":"Tree","target":"scala.Tree","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"exactMatch","ref":{"title":"Boolean","tpeLink":{"title":"Boolean","target":"scala.Boolean","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>The reverse path of untyped trees starting with a tree that closest matches\n <code>tree</code> and ending in the untyped tree at the root of the compilation unit\n specified by <code>ctx</code>.</p>","short":"<p>The reverse path of untyped trees starting with a tree that closest matches\n <code>tree</code> and ending in the untyped tree at the root of the compilation unit\n specified by <code>ctx</code>.</p>","authors":[],"see":[],"throws":{},"valueParams":{"exactMatch":"<p>If <code>true</code>, the path must start with a node that exactly\n                      matches <code>tree</code>, or <code>Nil</code> is returned.\n                      If <code>false</code> the path might start with a node enclosing\n                      the logical position of <code>tree</code>.\n Note: A complication concerns member definitions. ValDefs and DefDefs\n have after desugaring a position that spans just the name of the symbol being\n defined and nothing else. So we look instead for an untyped tree approximating the\n envelope of the definition, and declare success if we find another DefTree.</p>"},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"untypedPath","modifiers":[],"path":["dotty","tools","dotc","ast","NavigateAST$","untypedPath"],"returnValue":{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"Positioned","tpeLink":{"title":"Positioned","target":"scala.Positioned","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"pos","ref":{"title":"Position","tpeLink":{"title":"Position","target":"scala.Position","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>The reverse part of the untyped root of the compilation unit of <code>ctx</code> to\n position <code>pos</code>.\n</p>","short":"<p>The reverse part of the untyped root of the compilation unit of <code>ctx</code> to\n position <code>pos</code>.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"untypedPath$default$2","modifiers":[],"path":["dotty","tools","dotc","ast","NavigateAST$","untypedPath$default$2"],"returnValue":{"title":"Boolean","tpeLink":{"title":"Boolean","target":"scala.Boolean","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[],"comment":{"body":"<p>The reverse path of untyped trees starting with a tree that closest matches\n <code>tree</code> and ending in the untyped tree at the root of the compilation unit\n specified by <code>ctx</code>.</p>","short":"<p>The reverse path of untyped trees starting with a tree that closest matches\n <code>tree</code> and ending in the untyped tree at the root of the compilation unit\n specified by <code>ctx</code>.</p>","authors":[],"see":[],"throws":{},"valueParams":{"exactMatch":"<p>If <code>true</code>, the path must start with a node that exactly\n                      matches <code>tree</code>, or <code>Nil</code> is returned.\n                      If <code>false</code> the path might start with a node enclosing\n                      the logical position of <code>tree</code>.\n Note: A complication concerns member definitions. ValDefs and DefDefs\n have after desugaring a position that spans just the name of the symbol being\n defined and nothing else. So we look instead for an untyped tree approximating the\n envelope of the definition, and declare success if we find another DefTree.</p>"},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"}],"modifiers":["final"],"path":["dotc","ast","NavigateAST$"],"superTypes":[],"comment":{"body":"<p>Utility functions to go from typed to untyped ASTs</p>","short":"<p>Utility functions to go from typed to untyped ASTs</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"object"},{"name":"PluggableTransformers","members":[],"modifiers":["final"],"path":["dotc","ast","PluggableTransformers$"],"superTypes":[],"kind":"object"},{"name":"Positioned","members":[{"name":"addPos","modifiers":[],"path":["dotty","tools","dotc","ast","Positioned","addPos"],"returnValue":{"title":"Positioned","tpeLink":{"title":"Positioned","target":"scala.Positioned","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"pos","ref":{"title":"Position","tpeLink":{"title":"Position","target":"scala.Position","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false}],"comment":{"body":"<p>This item with a position that's the union of the given <code>pos</code> and the\n current position.\n</p>","short":"<p>This item with a position that's the union of the given <code>pos</code> and the\n current position.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"checkPos","modifiers":[],"path":["dotty","tools","dotc","ast","Positioned","checkPos"],"returnValue":{"title":"Unit","tpeLink":{"title":"Unit","target":"scala.Unit","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"nonOverlapping","ref":{"title":"Boolean","tpeLink":{"title":"Boolean","target":"scala.Boolean","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>Check that all positioned items in this tree satisfy the following conditions:</p><ul><li>Parent positions contain child positions</li><li>If item is a non-empty tree, it has a position\n</li></ul>","short":"<p>Check that all positioned items in this tree satisfy the following conditions:</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"contains","modifiers":[],"path":["dotty","tools","dotc","ast","Positioned","contains"],"returnValue":{"title":"Boolean","tpeLink":{"title":"Boolean","target":"scala.Boolean","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"that","ref":{"title":"Positioned","tpeLink":{"title":"Positioned","target":"scala.Positioned","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false}],"kind":"def"},{"name":"curPos","modifiers":["private"],"path":["dotty","tools","dotc","ast","Positioned","curPos"],"returnValue":{"title":"Position","tpeLink":{"title":"Position","target":"scala.Position","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"kind":"val"},{"name":"initialPos","modifiers":[],"path":["dotty","tools","dotc","ast","Positioned","initialPos"],"returnValue":{"title":"Position","tpeLink":{"title":"Position","target":"scala.Position","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[],"comment":{"body":"<p>The initial, synthetic position. This is usually the union of all positioned children's positions.\n</p>","short":"<p>The initial, synthetic position.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"pos","modifiers":[],"path":["dotty","tools","dotc","ast","Positioned","pos"],"returnValue":{"title":"Position","tpeLink":{"title":"Position","target":"scala.Position","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[],"comment":{"body":"<p>The item's position.\n</p>","short":"<p>The item's position.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"setChildPositions","modifiers":["private"],"path":["dotty","tools","dotc","ast","Positioned","setChildPositions"],"returnValue":{"title":"Unit","tpeLink":{"title":"Unit","target":"scala.Unit","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"pos","ref":{"title":"Position","tpeLink":{"title":"Position","target":"scala.Position","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false}],"comment":{"body":"<p>If any children of this node do not have positions,\n fit their positions between the positions of the known subtrees\n and transitively visit their children.\n The method is likely time-critical because it is invoked on any node\n we create, so we want to avoid object allocations in the common case.\n The method is naturally expressed as two mutually (tail-)recursive\n functions, one which computes the next element to consider or terminates if there\n is none and the other which propagates the position information to that element.\n But since mutual tail recursion is not supported in Scala, we express it instead\n as a while loop with a termination by return in the middle.\n</p>","short":"<p>If any children of this node do not have positions,\n fit their positions between the positions of the known subtrees\n and transitively visit their children.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"setPos","modifiers":["protected"],"path":["dotty","tools","dotc","ast","Positioned","setPos"],"returnValue":{"title":"Unit","tpeLink":{"title":"Unit","target":"scala.Unit","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"pos","ref":{"title":"Position","tpeLink":{"title":"Position","target":"scala.Position","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false}],"comment":{"body":"<p>Destructively update <code>curPos</code> to given position. Also, set any missing\n positions in children.\n</p>","short":"<p>Destructively update <code>curPos</code> to given position.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"setPosUnchecked","modifiers":[],"path":["dotty","tools","dotc","ast","Positioned","setPosUnchecked"],"returnValue":{"title":"Unit","tpeLink":{"title":"Unit","target":"scala.Unit","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"pos","ref":{"title":"Position","tpeLink":{"title":"Position","target":"scala.Position","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false}],"comment":{"body":"<p>Set position of this tree only, without performing\n any checks of consistency with - or updates of - other positions.\n Called from Unpickler when entering positions.\n</p>","short":"<p>Set position of this tree only, without performing\n any checks of consistency with - or updates of - other positions.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"unionPos","modifiers":["private"],"path":["dotty","tools","dotc","ast","Positioned","unionPos"],"returnValue":{"title":"Position","tpeLink":{"title":"Position","target":"scala.Position","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"pos","ref":{"title":"Position","tpeLink":{"title":"Position","target":"scala.Position","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"xs","ref":{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"low":{"title":"Nothing","tpeLink":{"title":"Nothing","target":"scala.Nothing","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"high":{"title":"Any","tpeLink":{"title":"Any","target":"scala.Any","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"kind":"BoundsReference"}],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false}],"kind":"def"},{"name":"withPos","modifiers":[],"path":["dotty","tools","dotc","ast","Positioned","withPos"],"returnValue":{"title":"Positioned","tpeLink":{"title":"Positioned","target":"scala.Positioned","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"pos","ref":{"title":"Position","tpeLink":{"title":"Position","target":"scala.Position","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false}],"comment":{"body":"<p>A positioned item like this one with the position set to <code>pos</code>.\n if the positioned item is source-derived, a clone is returned.\n If the positioned item is synthetic, the position is updated\n destructively and the item itself is returned.\n</p>","short":"<p>A positioned item like this one with the position set to <code>pos</code>.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"withPos","modifiers":[],"path":["dotty","tools","dotc","ast","Positioned","withPos"],"returnValue":{"title":"Positioned","tpeLink":{"title":"Positioned","target":"scala.Positioned","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"posd","ref":{"title":"Positioned","tpeLink":{"title":"Positioned","target":"scala.Positioned","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false}],"kind":"def"}],"modifiers":["abstract"],"path":["dotc","ast","Positioned"],"typeParams":[],"constructors":[[{"list":[],"isImplicit":false}]],"superTypes":[{"title":"DotClass","target":"dotty.tools.dotc.util.DotClass","kind":"NoLink"},{"title":"Product","target":"scala.Product","kind":"NoLink"}],"comment":{"body":"<p>A base class for things that have positions (currently: modifiers and trees)\n</p>","short":"<p>A base class for things that have positions (currently: modifiers and trees)\n</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"class"}],"path":["dotc","ast"],"kind":"package"};
                dotty.tools.doc.client.DottyDoc().main(document.getElementById("main-container"));
            </script>
        </div>
    </body>
</html>
