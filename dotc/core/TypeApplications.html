<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset = "utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <meta http-equiv="x-ua-compatible" content="ie=edge">

        <title>Dottydoc - TypeApplications</title>

        <script type="text/javascript" src="../../docassets/material.min.js"></script>
        <script type="text/javascript" src="../../docassets/highlight.pack.js"></script>
        <script type="text/javascript" src="../../docassets/index.js"></script>
        <script type="text/javascript" src="../../docassets/dottydoc.js"></script>
        <link rel="stylesheet" href="../../docassets/material-icons.css">
        <link rel="stylesheet" href="../../docassets/material.min.css">
        <link rel="stylesheet" href="../../docassets/github.css">
        <link rel="stylesheet" href="../../docassets/index.css">
    </head>
    <body>
        <div id="main-container">
            <script>
                Index.currentEntity = {"name":"TypeApplications","members":[{"name":"EtaExpand","modifiers":[],"path":["dotty","tools","dotc","core","TypeApplications","EtaExpand"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"tparams","ref":{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"TypeSymbol","tpeLink":{"title":"TypeSymbol","target":"scala.TypeSymbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>Convert a type constructor <code>TC</code> which has type parameters <code>T1, ..., Tn</code>\n in a context where type parameters <code>U1,...,Un</code> are expected to</p><p>    LambdaXYZ { Apply = TC[hk$0, ..., hk$n] }</p><p> Here, XYZ corresponds to the variances of</p><ul><li><code>U1,...,Un</code> if the variances of <code>T1,...,Tn</code> are pairwise compatible with <code>U1,...,Un</code>,</li><li><code>T1,...,Tn</code> otherwise.\n v1 is compatible with v2, if v1 = v2 or v2 is non-variant.\n</li></ul>","short":"<p>Convert a type constructor <code>TC</code> which has type parameters <code>T1, ..., Tn</code>\n in a context where type parameters <code>U1,...,Un</code> are expected to</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"EtaExpandIfHK","modifiers":[],"path":["dotty","tools","dotc","core","TypeApplications","EtaExpandIfHK"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"bound","ref":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>Eta expand if <code>self</code> is a (non-lambda) class reference and <code>bound</code> is a higher-kinded type</p>","short":"<p>Eta expand if <code>self</code> is a (non-lambda) class reference and <code>bound</code> is a higher-kinded type</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"LambdaAbstract","modifiers":[],"path":["dotty","tools","dotc","core","TypeApplications","LambdaAbstract"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"tparams","ref":{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"TypeParamInfo","tpeLink":{"title":"TypeParamInfo","target":"scala.TypeParamInfo","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>Lambda abstract <code>self</code> with given type parameters. Examples:</p><p>     type T[X] = U        becomes    type T = [X] -> U\n     type T[X] >: L <: U  becomes    type T >: L <: ([X] -> U)</p><p> TODO: Handle parameterized lower bounds\n</p>","short":"<p>Lambda abstract <code>self</code> with given type parameters.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"adaptHkVariances","modifiers":[],"path":["dotty","tools","dotc","core","TypeApplications","adaptHkVariances"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"bound","ref":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>If argument A and type parameter P are higher-kinded, adapt the variances\n of A to those of P, ensuring that the variances of the type lambda A\n agree with the variances of corresponding higher-kinded type parameters of P. Example:</p><p>    class GenericCompanion[+CC[X]]\n    GenericCompanion[List]</p><p> with adaptHkVariances, the argument <code>List</code> will expand to</p><p>    [X] => List[X]</p><p> instead of</p><p>    [+X] => List[X]</p><p> even though <code>List</code> is covariant. This adaptation is necessary to ignore conflicting\n variances in overriding members that have types of hk-type parameters such as\n <code>GenericCompanion[GenTraversable]</code> or <code>GenericCompanion[ListBuffer]</code>.\n When checking overriding, we need to validate the subtype relationship</p><p>     GenericCompanion-> ListBuffer[X <: GenericCompanion-> GenTraversable[X</p><p>  Without adaptation, this would be false, and hence an overriding error would\n  result. But with adaptation, the rhs argument will be adapted to</p><p>    [X] -> GenTraversable[X]</p><p>  which makes the subtype test succeed. The crucial point here is that, since\n  GenericCompanion only expects a non-variant CC, the fact that GenTraversable\n  is covariant is irrelevant, so can be ignored.\n</p>","short":"<p>If argument A and type parameter P are higher-kinded, adapt the variances\n of A to those of P, ensuring that the variances of the type lambda A\n agree with the variances of corresponding higher-kinded type parameters of P.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"appliedTo","modifiers":["final"],"path":["dotty","tools","dotc","core","TypeApplications","appliedTo"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"args","ref":{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>The type representing</p><p>    T[U1, ..., Un]</p><p> where</p>","short":"<p>The type representing</p>","authors":[],"see":[],"throws":{},"valueParams":{"self":"<h1> <code>T</code></h1>","args":"<h1> <code>U1,...,Un</code></h1>"},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"appliedTo","modifiers":["final"],"path":["dotty","tools","dotc","core","TypeApplications","appliedTo"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"arg","ref":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"kind":"def"},{"name":"appliedTo","modifiers":["final"],"path":["dotty","tools","dotc","core","TypeApplications","appliedTo"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"arg1","ref":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"arg2","ref":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"kind":"def"},{"name":"applyIfParameterized","modifiers":["final"],"path":["dotty","tools","dotc","core","TypeApplications","applyIfParameterized"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"args","ref":{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"kind":"def"},{"name":"argInfo","modifiers":["final"],"path":["dotty","tools","dotc","core","TypeApplications","argInfo"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>If this is the image of a type argument; recover the type argument,\n otherwise NoType.\n</p>","short":"<p>If this is the image of a type argument; recover the type argument,\n otherwise NoType.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"argInfos","modifiers":["final"],"path":["dotty","tools","dotc","core","TypeApplications","argInfos"],"returnValue":{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>If this is an encoding of a (partially) applied type, return its arguments,\n otherwise return Nil.\n Existential types in arguments are returned as TypeBounds instances.\n</p>","short":"<p>If this is an encoding of a (partially) applied type, return its arguments,\n otherwise return Nil.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"argTypes","modifiers":[],"path":["dotty","tools","dotc","core","TypeApplications","argTypes"],"returnValue":{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>Argument types where existential types in arguments are disallowed</p>","short":"<p>Argument types where existential types in arguments are disallowed</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"argTypesHi","modifiers":[],"path":["dotty","tools","dotc","core","TypeApplications","argTypesHi"],"returnValue":{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>Argument types where existential types in arguments are approximated by their upper bound</p>","short":"<p>Argument types where existential types in arguments are approximated by their upper bound</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"argTypesLo","modifiers":[],"path":["dotty","tools","dotc","core","TypeApplications","argTypesLo"],"returnValue":{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>Argument types where existential types in arguments are approximated by their lower bound</p>","short":"<p>Argument types where existential types in arguments are approximated by their lower bound</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"baseArgInfos","modifiers":["final"],"path":["dotty","tools","dotc","core","TypeApplications","baseArgInfos"],"returnValue":{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"base","ref":{"title":"Symbol","tpeLink":{"title":"Symbol","target":"scala.Symbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>The type arguments of this type's base type instance wrt. <code>base</code>.\n Existential types in arguments are returned as TypeBounds instances.\n</p>","short":"<p>The type arguments of this type's base type instance wrt.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"baseArgTypes","modifiers":["final"],"path":["dotty","tools","dotc","core","TypeApplications","baseArgTypes"],"returnValue":{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"base","ref":{"title":"Symbol","tpeLink":{"title":"Symbol","target":"scala.Symbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>The type arguments of this type's base type instance wrt.<code>base</code>.\n Existential types in arguments are disallowed.\n</p>","short":"<p>The type arguments of this type's base type instance wrt.<code>base</code>.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"baseArgTypesHi","modifiers":["final"],"path":["dotty","tools","dotc","core","TypeApplications","baseArgTypesHi"],"returnValue":{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"base","ref":{"title":"Symbol","tpeLink":{"title":"Symbol","target":"scala.Symbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>The type arguments of this type's base type instance wrt.<code>base</code>.\n Existential types in arguments are approximated by their upper bound.\n</p>","short":"<p>The type arguments of this type's base type instance wrt.<code>base</code>.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"baseArgTypesLo","modifiers":["final"],"path":["dotty","tools","dotc","core","TypeApplications","baseArgTypesLo"],"returnValue":{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"base","ref":{"title":"Symbol","tpeLink":{"title":"Symbol","target":"scala.Symbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>The type arguments of this type's base type instance wrt.<code>base</code>.\n Existential types in arguments are approximated by their lower bound.\n</p>","short":"<p>The type arguments of this type's base type instance wrt.<code>base</code>.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"baseTypeWithArgs","modifiers":["final"],"path":["dotty","tools","dotc","core","TypeApplications","baseTypeWithArgs"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"base","ref":{"title":"Symbol","tpeLink":{"title":"Symbol","target":"scala.Symbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>The base type including all type arguments and applicable refinements\n of this type. Refinements are applicable if they refine a member of\n the parent type which furthermore is not a name-mangled type parameter.\n Existential types in arguments are returned as TypeBounds instances.\n</p>","short":"<p>The base type including all type arguments and applicable refinements\n of this type.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"dropAlias","modifiers":[],"path":["dotty","tools","dotc","core","TypeApplications","dropAlias"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>If this is a type alias, its underlying type, otherwise the type itself</p>","short":"<p>If this is a type alias, its underlying type, otherwise the type itself</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"elemType","modifiers":[],"path":["dotty","tools","dotc","core","TypeApplications","elemType"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>The element type of a sequence or array</p>","short":"<p>The element type of a sequence or array</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"ensureHK","modifiers":[],"path":["dotty","tools","dotc","core","TypeApplications","ensureHK"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>If self is not higher-kinded, eta expand it.</p>","short":"<p>If self is not higher-kinded, eta expand it.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"hkTypeParams","modifiers":["final"],"path":["dotty","tools","dotc","core","TypeApplications","hkTypeParams"],"returnValue":{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"TypeParamInfo","tpeLink":{"title":"TypeParamInfo","target":"scala.TypeParamInfo","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>If <code>self</code> is a higher-kinded type, its type parameters, otherwise Nil</p>","short":"<p>If <code>self</code> is a higher-kinded type, its type parameters, otherwise Nil</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"isHK","modifiers":[],"path":["dotty","tools","dotc","core","TypeApplications","isHK"],"returnValue":{"title":"Boolean","tpeLink":{"title":"Boolean","target":"scala.Boolean","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>Is self type higher-kinded (i.e. of kind != \"*\")?</p>","short":"<p>Is self type higher-kinded (i.e.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"namedTypeParams","modifiers":["final"],"path":["dotty","tools","dotc","core","TypeApplications","namedTypeParams"],"returnValue":{"title":"Set","tpeLink":{"title":"Set","target":"scala.collection.immutable.Set","kind":"NoLink"},"paramLinks":[{"title":"TypeSymbol","tpeLink":{"title":"TypeSymbol","target":"scala.TypeSymbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>The named type parameters declared or inherited by this type.\n These are all uninstantiated named type parameters of this type or one\n of its base types.\n</p>","short":"<p>The named type parameters declared or inherited by this type.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"safeAppliedTo","modifiers":["final"],"path":["dotty","tools","dotc","core","TypeApplications","safeAppliedTo"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"args","ref":{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>A cycle-safe version of <code>appliedTo</code> where computing type parameters do not force\n the typeconstructor. Instead, if the type constructor is completing, we make\n up hk type parameters matching the arguments. This is needed when unpickling\n Scala2 files such as <code>scala.collection.generic.Mapfactory</code>.\n</p>","short":"<p>A cycle-safe version of <code>appliedTo</code> where computing type parameters do not force\n the typeconstructor.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"safeDealias","modifiers":[],"path":["dotty","tools","dotc","core","TypeApplications","safeDealias"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>Dealias type if it can be done without forcing the TypeRef's info</p>","short":"<p>Dealias type if it can be done without forcing the TypeRef's info</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"self","modifiers":[],"path":["dotty","tools","dotc","core","TypeApplications","self"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"kind":"val"},{"name":"toBounds","modifiers":["final"],"path":["dotty","tools","dotc","core","TypeApplications","toBounds"],"returnValue":{"title":"TypeBounds","tpeLink":{"title":"TypeBounds","target":"scala.TypeBounds","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"tparam","ref":{"title":"TypeParamInfo","tpeLink":{"title":"TypeParamInfo","target":"scala.TypeParamInfo","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>Turn this type, which is used as an argument for\n type parameter <code>tparam</code>, into a TypeBounds RHS\n</p>","short":"<p>Turn this type, which is used as an argument for\n type parameter <code>tparam</code>, into a TypeBounds RHS\n</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"translateParameterized","modifiers":[],"path":["dotty","tools","dotc","core","TypeApplications","translateParameterized"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"from","ref":{"title":"ClassSymbol","tpeLink":{"title":"ClassSymbol","target":"scala.ClassSymbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"to","ref":{"title":"ClassSymbol","tpeLink":{"title":"ClassSymbol","target":"scala.ClassSymbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>Translate a type of the form From[T] to To[T], keep other types as they are.\n <code>from</code> and <code>to</code> must be static classes, both with one type parameter, and the same variance.\n Do the same for by name types => From[T] and => To[T]\n</p>","short":"<p>Translate a type of the form From[T] to To[T], keep other types as they are.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"typeParamSymbols","modifiers":["final"],"path":["dotty","tools","dotc","core","TypeApplications","typeParamSymbols"],"returnValue":{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"TypeSymbol","tpeLink":{"title":"TypeSymbol","target":"scala.TypeSymbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>If <code>self</code> is a generic class, its type parameter symbols, otherwise Nil</p>","short":"<p>If <code>self</code> is a generic class, its type parameter symbols, otherwise Nil</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"typeParams","modifiers":["final"],"path":["dotty","tools","dotc","core","TypeApplications","typeParams"],"returnValue":{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"TypeParamInfo","tpeLink":{"title":"TypeParamInfo","target":"scala.TypeParamInfo","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>The type parameters of this type are:\n For a ClassInfo type, the type parameters of its class.\n For a typeref referring to a class, the type parameters of the class.\n For a typeref referring to a Lambda class, the type parameters of\n   its right hand side or upper bound.\n For a refinement type, the type parameters of its parent, dropping\n any type parameter that is-rebound by the refinement. \"Re-bind\" means:\n The refinement contains a TypeAlias for the type parameter, or\n it introduces bounds for the type parameter, and we are not in the\n special case of a type Lambda, where a LambdaTrait gets refined\n with the bounds on its hk args. See <code>LambdaAbstract</code>, where these\n types get introduced, and see <code>isBoundedLambda</code> below for the test.\n</p>","short":"<p>The type parameters of this type are:\n For a ClassInfo type, the type parameters of its class.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"underlyingIfRepeated","modifiers":[],"path":["dotty","tools","dotc","core","TypeApplications","underlyingIfRepeated"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"isJava","ref":{"title":"Boolean","tpeLink":{"title":"Boolean","target":"scala.Boolean","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>If this is repeated parameter type, its underlying Seq type,\n or, if isJava is true, Array type, else the type itself.\n</p>","short":"<p>If this is repeated parameter type, its underlying Seq type,\n or, if isJava is true, Array type, else the type itself.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"widenToNamedTypeParams","modifiers":["final"],"path":["dotty","tools","dotc","core","TypeApplications","widenToNamedTypeParams"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"params","ref":{"title":"Set","tpeLink":{"title":"Set","target":"scala.collection.immutable.Set","kind":"NoLink"},"paramLinks":[{"title":"TypeSymbol","tpeLink":{"title":"TypeSymbol","target":"scala.TypeSymbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>The smallest supertype of this type that instantiated none of the named type parameters\n in <code>params</code>. That is, for each named type parameter <code>p</code> in <code>params</code>, either there is\n no type field named <code>p</code> in this type, or <code>p</code> is a named type parameter of this type.\n The first case is important for the recursive case of AndTypes, because some of their operands might\n be missing the named parameter altogether, but the AndType as a whole can still\n contain it.\n</p>","short":"<p>The smallest supertype of this type that instantiated none of the named type parameters\n in <code>params</code>.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"withoutArgs","modifiers":["final"],"path":["dotty","tools","dotc","core","TypeApplications","withoutArgs"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"typeArgs","ref":{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false}],"comment":{"body":"<p>The core type without any type arguments.</p>","short":"<p>The core type without any type arguments.</p>","authors":[],"see":[],"throws":{},"valueParams":{"`typeArgs`":"<p>must be the type arguments of this type.</p>"},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"}],"modifiers":["final"],"path":["dotc","core","TypeApplications"],"typeParams":[],"constructors":[[{"list":[{"title":"self","ref":{"title":"Type","tpeLink":{"title":"Type","query":"Type","kind":"UnsetLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false}]],"superTypes":[{"title":"AnyVal","target":"scala.AnyVal","kind":"NoLink"}],"comment":{"body":"<p>A decorator that provides methods for modeling type application</p>","short":"<p>A decorator that provides methods for modeling type application</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"class"};
                dotty.tools.doc.client.DottyDoc().main(document.getElementById("main-container"));
            </script>
        </div>
    </body>
</html>
