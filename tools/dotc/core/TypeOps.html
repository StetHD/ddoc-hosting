<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset = "utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <meta http-equiv="x-ua-compatible" content="ie=edge">

        <title>Dottydoc - TypeOps</title>

        <script type="text/javascript" src="../../../docassets/material.min.js"></script>
        <script type="text/javascript" src="../../../docassets/highlight.pack.js"></script>
        <script type="text/javascript" src="../../../docassets/index.js"></script>
        <script type="text/javascript" src="../../../docassets/dottydoc.js"></script>
        <link rel="stylesheet" href="../../../docassets/material-icons.css">
        <link rel="stylesheet" href="../../../docassets/material.min.css">
        <link rel="stylesheet" href="../../../docassets/github.css">
        <link rel="stylesheet" href="../../../docassets/index.css">
    </head>
    <body>
        <div id="main-container">
            <script>
                Index.currentEntity = {"name":"TypeOps","members":[{"name":"AsSeenFromMap","members":[{"name":"apply","modifiers":[],"path":["dotty","tools","dotc","core","TypeOps","AsSeenFromMap","apply"],"returnValue":{"title":"R","tpeLink":{"title":"R","target":"scala.R","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"tp","ref":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false}],"kind":"def"},{"name":"cls","modifiers":["private"],"path":["dotty","tools","dotc","core","TypeOps","AsSeenFromMap","cls"],"returnValue":{"title":"Symbol","tpeLink":{"title":"Symbol","target":"scala.Symbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"kind":"val"},{"name":"currentVariance","modifiers":[],"path":["dotty","tools","dotc","core","TypeOps","AsSeenFromMap","currentVariance"],"returnValue":{"title":"Int","tpeLink":{"title":"Int","target":"scala.Int","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[],"comment":{"body":"<p>A method to export the current variance of the map</p>","short":"<p>A method to export the current variance of the map</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"pre","modifiers":["private"],"path":["dotty","tools","dotc","core","TypeOps","AsSeenFromMap","pre"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"kind":"val"}],"modifiers":[],"path":["tools","dotc","core","AsSeenFromMap"],"typeParams":[],"constructors":[[{"list":[{"title":"pre","ref":{"title":"Type","tpeLink":{"title":"Type","query":"Type","kind":"UnsetLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"cls","ref":{"title":"Symbol","tpeLink":{"title":"Symbol","query":"Symbol","kind":"UnsetLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false}]],"superTypes":[{"title":"TypeMap","target":"dotty.tools.dotc.core.Types$.TypeMap","kind":"NoLink"}],"comment":{"body":"<p>The TypeMap handling the asSeenFrom in more complicated cases</p>","short":"<p>The TypeMap handling the asSeenFrom in more complicated cases</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"class"},{"name":"SimplifyMap","members":[{"name":"apply","modifiers":[],"path":["dotty","tools","dotc","core","TypeOps","SimplifyMap","apply"],"returnValue":{"title":"R","tpeLink":{"title":"R","target":"scala.R","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"tp","ref":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false}],"kind":"def"}],"modifiers":[],"path":["tools","dotc","core","SimplifyMap"],"typeParams":[],"constructors":[[{"list":[],"isImplicit":false}]],"superTypes":[{"title":"TypeMap","target":"dotty.tools.dotc.core.Types$.TypeMap","kind":"NoLink"}],"kind":"class"},{"name":"asSeenFrom","modifiers":["final"],"path":["dotty","tools","dotc","core","TypeOps","asSeenFrom"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"tp","ref":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"pre","ref":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"cls","ref":{"title":"Symbol","tpeLink":{"title":"Symbol","target":"scala.Symbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false}],"comment":{"body":"<p>The type <code>tp</code> as seen from prefix <code>pre</code> and owner <code>cls</code>. See the spec\n for what this means. Called very often, so the code is optimized heavily.</p><p> A tricky aspect is what to do with unstable prefixes. E.g. say we have a class</p><p>   class C { type T; def f(x: T): T }</p><p> and an expression <code>e</code> of type <code>C</code>. Then computing the type of <code>e.f</code> leads\n to the query asSeenFrom(<code>C</code>, <code>(x: T)T</code>). What should its result be? The\n naive answer <code>(x: C#T)C#T</code> is incorrect given that we treat <code>C#T</code> as the existential\n <code>exists(c: C)c.T</code>. What we need to do instead is to skolemize the existential. So\n the answer would be <code>(x: c.T)c.T</code> for some (unknown) value <code>c</code> of type <code>C</code>.\n <code>c.T</code> is expressed in the compiler as a skolem type <code>Skolem(C)</code>.</p><p> Now, skolemization is messy and expensive, so we want to do it only if we absolutely\n must. Also, skolemizing immediately would mean that asSeenFrom was no longer\n idempotent - each call would return a type with a different skolem.\n Instead we produce an annotated type that marks the prefix as unsafe:</p><p>    (x: (C @ UnsafeNonvariant)#T)C#T</p><p> We also set a global state flag <code>unsafeNonvariant</code> to the current run.\n When typing a Select node, typer will check that flag, and if it\n points to the current run will scan the result type of the select for</p>","short":"<p>The type <code>tp</code> as seen from prefix <code>pre</code> and owner <code>cls</code>.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"asSeenFrom","modifiers":["private"],"path":["dotty","tools","dotc","core","TypeOps","asSeenFrom"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"tp","ref":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"pre","ref":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"cls","ref":{"title":"Symbol","tpeLink":{"title":"Symbol","target":"scala.Symbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"theMap","ref":{"title":"AsSeenFromMap","tpeLink":{"title":"AsSeenFromMap","target":"scala.AsSeenFromMap","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false}],"comment":{"body":"<p>Helper method, taking a map argument which is instantiated only for more\n complicated cases of asSeenFrom.\n</p>","short":"<p>Helper method, taking a map argument which is instantiated only for more\n complicated cases of asSeenFrom.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"boundsViolations","modifiers":[],"path":["dotty","tools","dotc","core","TypeOps","boundsViolations"],"returnValue":{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"BoundsViolation","tpeLink":{"title":"BoundsViolation","target":"scala.BoundsViolation","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"args","ref":{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"Tree","tpeLink":{"title":"Tree","target":"scala.Tree","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"boundss","ref":{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"TypeBounds","tpeLink":{"title":"TypeBounds","target":"scala.TypeBounds","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"instantiate","ref":{"args":[{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"}],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"kind": "FunctionReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>The list of violations where arguments are not within bounds.</p>","short":"<p>The list of violations where arguments are not within bounds.</p>","authors":[],"see":[],"throws":{},"valueParams":{"instantiate":"<p>A function that maps a bound type and the list of argument types to a resulting type.\n                       Needed to handle bounds that refer to other bounds.</p>","boundss":"<p>The list of type bounds</p>","args":"<p>The arguments</p>"},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"canAutoTuple","modifiers":[],"path":["dotty","tools","dotc","core","TypeOps","canAutoTuple"],"returnValue":{"title":"Boolean","tpeLink":{"title":"Boolean","target":"scala.Boolean","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[],"comment":{"body":"<p>Is auto-tupling enabled?</p>","short":"<p>Is auto-tupling enabled?</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"deskolemize","members":[{"name":"apply","modifiers":[],"path":["dotty","tools","dotc","core","TypeOps","deskolemize$","apply"],"returnValue":{"title":"R","tpeLink":{"title":"R","target":"scala.R","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"tp","ref":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false}],"kind":"def"},{"name":"seen","modifiers":["private"],"path":["dotty","tools","dotc","core","TypeOps","deskolemize$","seen"],"returnValue":{"title":"Set","tpeLink":{"title":"Set","target":"scala.collection.immutable.Set","kind":"NoLink"},"paramLinks":[{"title":"SkolemType","tpeLink":{"title":"SkolemType","target":"scala.SkolemType","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"kind":"val"},{"name":"seen_=","modifiers":["private","<accessor>"],"path":["dotty","tools","dotc","core","TypeOps","deskolemize$","seen_="],"returnValue":{"title":"Unit","tpeLink":{"title":"Unit","target":"scala.Unit","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"x$1","ref":{"title":"Set","tpeLink":{"title":"Set","target":"scala.collection.immutable.Set","kind":"NoLink"},"paramLinks":[{"title":"SkolemType","tpeLink":{"title":"SkolemType","target":"scala.SkolemType","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false}],"kind":"def"}],"modifiers":["final"],"path":["tools","dotc","core","deskolemize$"],"superTypes":[{"title":"ApproximatingTypeMap","target":"dotty.tools.dotc.core.Types$.ApproximatingTypeMap","kind":"NoLink"}],"comment":{"body":"<p>Approximate a type <code>tp</code> with a type that does not contain skolem types.</p>","short":"<p>Approximate a type <code>tp</code> with a type that does not contain skolem types.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"object"},{"name":"dynamicsEnabled","modifiers":[],"path":["dotty","tools","dotc","core","TypeOps","dynamicsEnabled"],"returnValue":{"title":"Boolean","tpeLink":{"title":"Boolean","target":"scala.Boolean","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[],"kind":"def"},{"name":"enterArgBinding","modifiers":["private"],"path":["dotty","tools","dotc","core","TypeOps","enterArgBinding"],"returnValue":{"title":"Unit","tpeLink":{"title":"Unit","target":"scala.Unit","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"formal","ref":{"title":"Symbol","tpeLink":{"title":"Symbol","target":"scala.Symbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"info","ref":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"cls","ref":{"title":"ClassSymbol","tpeLink":{"title":"ClassSymbol","target":"scala.ClassSymbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"decls","ref":{"title":"Scope","tpeLink":{"title":"Scope","target":"scala.Scope","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false}],"comment":{"body":"<p>Not currently needed:</p><p>  def liftToRec(f: (Type, Type) => Type)(tp1: Type, tp2: Type)(implicit ctx: Context) = {\n    def f2(tp1: Type, tp2: Type): Type = tp2 match {\n      case tp2: RecType => tp2.rebind(f(tp1, tp2.parent))\n      case _ => f(tp1, tp2)\n    }\n    tp1 match {\n      case tp1: RecType => tp1.rebind(f2(tp1.parent, tp2))\n      case _ => f2(tp1, tp2)\n    }\n  }\n</p>","short":"<p>Not currently needed:</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"featureEnabled","modifiers":[],"path":["dotty","tools","dotc","core","TypeOps","featureEnabled"],"returnValue":{"title":"Boolean","tpeLink":{"title":"Boolean","target":"scala.Boolean","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"owner","ref":{"title":"ClassSymbol","tpeLink":{"title":"ClassSymbol","target":"scala.ClassSymbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"feature","ref":{"title":"TermName","tpeLink":{"title":"TermName","target":"scala.TermName","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false}],"comment":{"body":"<p>Is <code>feature</code> enabled in class <code>owner</code>?\n This is the case if one of the following two alternatives holds:</p><ol class=decimal><li>The feature is imported by a named import</li></ol><p>      import owner.feature</p><p> (the feature may be bunched with others, or renamed, but wildcard imports\n don't count).</p><p> 2. The feature is enabled by a compiler option</p><ul><li>language:<prefix>feature</li></ul><p> where <prefix> is the full name of the owner followed by a \".\" minus\n the prefix \"dotty.language.\".\n</p>","short":"<p>Is <code>feature</code> enabled in class <code>owner</code>?\n This is the case if one of the following two alternatives holds:</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"forwardRef","modifiers":[],"path":["dotty","tools","dotc","core","TypeOps","forwardRef"],"returnValue":{"title":"Unit","tpeLink":{"title":"Unit","target":"scala.Unit","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"argSym","ref":{"title":"Symbol","tpeLink":{"title":"Symbol","target":"scala.Symbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"from","ref":{"title":"Symbol","tpeLink":{"title":"Symbol","target":"scala.Symbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"to","ref":{"title":"TypeBounds","tpeLink":{"title":"TypeBounds","target":"scala.TypeBounds","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"cls","ref":{"title":"ClassSymbol","tpeLink":{"title":"ClassSymbol","target":"scala.ClassSymbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"decls","ref":{"title":"Scope","tpeLink":{"title":"Scope","target":"scala.Scope","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false}],"comment":{"body":"<p>If we have member definitions</p><p>    type argSym v= from\n    type from v= to</p><p> where the variances of both alias are the same, then enter a new definition</p><p>    type argSym v= to</p><p> unless a definition for <code>argSym</code> already exists in the current scope.\n</p>","short":"<p>If we have member definitions</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"harmonizeUnion","modifiers":[],"path":["dotty","tools","dotc","core","TypeOps","harmonizeUnion"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"tp","ref":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false}],"comment":{"body":"<p>Given a disjunction T1 | ... | Tn of types with potentially embedded\n type variables, constrain type variables further if this eliminates\n some of the branches of the disjunction. Do this also for disjunctions\n embedded in intersections, as parents in refinements, and in recursive types.</p><p> For instance, if <code>A</code> is an unconstrained type variable, then</p><p>     ArrayBuffer[Int] | ArrayBuffer[A]</p><p> is approximated by constraining <code>A</code> to be =:= to <code>Int</code> and returning <code>ArrayBuffer[Int]</code>\n instead of <code>ArrayBuffer[_ >: Int | A <: Int & A]</code>\n</p>","short":"<p>Given a disjunction T1 | ...</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"isLegalPrefix","modifiers":["private"],"path":["dotty","tools","dotc","core","TypeOps","isLegalPrefix"],"returnValue":{"title":"Boolean","tpeLink":{"title":"Boolean","target":"scala.Boolean","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"pre","ref":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"kind":"def"},{"name":"joinIfScala2","modifiers":["private"],"path":["dotty","tools","dotc","core","TypeOps","joinIfScala2"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"tp","ref":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false}],"comment":{"body":"<p>Under -language:Scala2: Replace or-types with their joins</p>","short":"<p>Under -language:Scala2: Replace or-types with their joins</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"makePackageObjPrefixExplicit","modifiers":[],"path":["dotty","tools","dotc","core","TypeOps","makePackageObjPrefixExplicit"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"tpe","ref":{"title":"NamedType","tpeLink":{"title":"NamedType","target":"scala.NamedType","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false}],"comment":{"body":"<p>If <code>tpe</code> is of the form <code>p.x</code> where <code>p</code> refers to a package\n but <code>x</code> is not owned by a package, expand it to</p><p>     p.package.x\n</p>","short":"<p>If <code>tpe</code> is of the form <code>p.x</code> where <code>p</code> refers to a package\n but <code>x</code> is not owned by a package, expand it to</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"normalizeToClassRefs","modifiers":[],"path":["dotty","tools","dotc","core","TypeOps","normalizeToClassRefs"],"returnValue":{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"TypeRef","tpeLink":{"title":"TypeRef","target":"scala.TypeRef","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"parents","ref":{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"cls","ref":{"title":"ClassSymbol","tpeLink":{"title":"ClassSymbol","target":"scala.ClassSymbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"decls","ref":{"title":"Scope","tpeLink":{"title":"Scope","target":"scala.Scope","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false}],"comment":{"body":"<p>Normalize a list of parent types of class <code>cls</code> that may contain refinements\n to a list of typerefs referring to classes, by converting all refinements to member\n definitions in scope <code>decls</code>. Can add members to <code>decls</code> as a side-effect.\n</p>","short":"<p>Normalize a list of parent types of class <code>cls</code> that may contain refinements\n to a list of typerefs referring to classes, by converting all refinements to member\n definitions in scope <code>decls</code>.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"orDominator","modifiers":[],"path":["dotty","tools","dotc","core","TypeOps","orDominator"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"tp","ref":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false}],"comment":{"body":"<p>Approximate union type by intersection of its dominators.\n That is, replace a union type Tn | ... | Tn\n by the smallest intersection type of base-class instances of T1,...,Tn.\n Example: Given</p><p>     trait C[+T]\n     trait D\n     class A extends C[A] with D\n     class B extends C[B] with D with E</p><p> we approximate <code>A | B</code> by <code>C[A | B] with D</code>\n</p>","short":"<p>Approximate union type by intersection of its dominators.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"scala2Mode","modifiers":[],"path":["dotty","tools","dotc","core","TypeOps","scala2Mode"],"returnValue":{"title":"Boolean","tpeLink":{"title":"Boolean","target":"scala.Boolean","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[],"kind":"def"},{"name":"simplify","modifiers":["final"],"path":["dotty","tools","dotc","core","TypeOps","simplify"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"tp","ref":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"theMap","ref":{"title":"SimplifyMap","tpeLink":{"title":"SimplifyMap","target":"scala.SimplifyMap","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false}],"comment":{"body":"<p>Implementation of Types#simplified</p>","short":"<p>Implementation of Types#simplified</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"testScala2Mode","modifiers":[],"path":["dotty","tools","dotc","core","TypeOps","testScala2Mode"],"returnValue":{"title":"Boolean","tpeLink":{"title":"Boolean","target":"scala.Boolean","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"msg","ref":{"title":"String","tpeLink":{"title":"String","target":"scala.String","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":true,"isRepeated":false,"kind":"NamedReference"},{"title":"pos","ref":{"title":"Position","tpeLink":{"title":"Position","target":"scala.Position","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false}],"kind":"def"}],"modifiers":[],"path":["tools","dotc","core","TypeOps"],"typeParams":[],"traitParams":[{"list":[],"isImplicit":false}],"superTypes":[],"kind":"trait"};
                dotty.tools.doc.client.DottyDoc().main(document.getElementById("main-container"));
            </script>
        </div>
    </body>
</html>
