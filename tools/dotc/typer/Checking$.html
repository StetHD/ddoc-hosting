<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset = "utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <meta http-equiv="x-ua-compatible" content="ie=edge">

        <title>Dottydoc - Checking</title>

        <script type="text/javascript" src="../../../docassets/material.min.js"></script>
        <script type="text/javascript" src="../../../docassets/highlight.pack.js"></script>
        <script type="text/javascript" src="../../../docassets/index.js"></script>
        <script type="text/javascript" src="../../../docassets/dottydoc.js"></script>
        <link rel="stylesheet" href="../../../docassets/material-icons.css">
        <link rel="stylesheet" href="../../../docassets/material.min.css">
        <link rel="stylesheet" href="../../../docassets/github.css">
        <link rel="stylesheet" href="../../../docassets/index.css">
    </head>
    <body>
        <div id="main-container">
            <script>
                Index.currentEntity = {"name":"Checking","members":[{"name":"CheckNonCyclicMap","members":[{"name":"apply","modifiers":["private"],"path":["dotty","tools","dotc","typer","Checking$","CheckNonCyclicMap","apply"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"tp","ref":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"cycleOK","ref":{"title":"Boolean","tpeLink":{"title":"Boolean","target":"scala.Boolean","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"nestedCycleOK","ref":{"title":"Boolean","tpeLink":{"title":"Boolean","target":"scala.Boolean","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false}],"kind":"def"},{"name":"apply","modifiers":[],"path":["dotty","tools","dotc","typer","Checking$","CheckNonCyclicMap","apply"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"tp","ref":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false}],"kind":"def"},{"name":"checkInfo","modifiers":[],"path":["dotty","tools","dotc","typer","Checking$","CheckNonCyclicMap","checkInfo"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"tp","ref":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false}],"comment":{"body":"<p>Check info <code>tp</code> for cycles. Throw CyclicReference for illegal cycles,\n break direct cycle with a LazyRef for legal, F-bounded cycles.\n</p>","short":"<p>Check info <code>tp</code> for cycles.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"ctx","modifiers":["private","implicit"],"path":["dotty","tools","dotc","typer","Checking$","CheckNonCyclicMap","ctx"],"returnValue":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"kind":"val"},{"name":"cycleOK","modifiers":["private"],"path":["dotty","tools","dotc","typer","Checking$","CheckNonCyclicMap","cycleOK"],"returnValue":{"title":"Boolean","tpeLink":{"title":"Boolean","target":"scala.Boolean","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"comment":{"body":"<p>Are cycles allowed within currently checked type?</p>","short":"<p>Are cycles allowed within currently checked type?</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"val"},{"name":"cycleOK_=","modifiers":["private","<accessor>"],"path":["dotty","tools","dotc","typer","Checking$","CheckNonCyclicMap","cycleOK_="],"returnValue":{"title":"Unit","tpeLink":{"title":"Unit","target":"scala.Unit","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"x$1","ref":{"title":"Boolean","tpeLink":{"title":"Boolean","target":"scala.Boolean","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false}],"comment":{"body":"<p>Are cycles allowed within currently checked type?</p>","short":"<p>Are cycles allowed within currently checked type?</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"lastChecked","modifiers":[],"path":["dotty","tools","dotc","typer","Checking$","CheckNonCyclicMap","lastChecked"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"comment":{"body":"<p>The last type top-level type checked when a CyclicReference occurs.</p>","short":"<p>The last type top-level type checked when a CyclicReference occurs.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"val"},{"name":"lastChecked_=","modifiers":["<accessor>"],"path":["dotty","tools","dotc","typer","Checking$","CheckNonCyclicMap","lastChecked_="],"returnValue":{"title":"Unit","tpeLink":{"title":"Unit","target":"scala.Unit","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"x$1","ref":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false}],"comment":{"body":"<p>The last type top-level type checked when a CyclicReference occurs.</p>","short":"<p>The last type top-level type checked when a CyclicReference occurs.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"nestedCycleOK","modifiers":["private"],"path":["dotty","tools","dotc","typer","Checking$","CheckNonCyclicMap","nestedCycleOK"],"returnValue":{"title":"Boolean","tpeLink":{"title":"Boolean","target":"scala.Boolean","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"comment":{"body":"<p>Are cycles allowed within nested refinedInfos of currently checked type?</p>","short":"<p>Are cycles allowed within nested refinedInfos of currently checked type?</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"val"},{"name":"nestedCycleOK_=","modifiers":["private","<accessor>"],"path":["dotty","tools","dotc","typer","Checking$","CheckNonCyclicMap","nestedCycleOK_="],"returnValue":{"title":"Unit","tpeLink":{"title":"Unit","target":"scala.Unit","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"x$1","ref":{"title":"Boolean","tpeLink":{"title":"Boolean","target":"scala.Boolean","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false}],"comment":{"body":"<p>Are cycles allowed within nested refinedInfos of currently checked type?</p>","short":"<p>Are cycles allowed within nested refinedInfos of currently checked type?</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"reportErrors","modifiers":["private"],"path":["dotty","tools","dotc","typer","Checking$","CheckNonCyclicMap","reportErrors"],"returnValue":{"title":"Boolean","tpeLink":{"title":"Boolean","target":"scala.Boolean","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"kind":"val"},{"name":"sym","modifiers":["private"],"path":["dotty","tools","dotc","typer","Checking$","CheckNonCyclicMap","sym"],"returnValue":{"title":"Symbol","tpeLink":{"title":"Symbol","target":"scala.Symbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"kind":"val"},{"name":"where","modifiers":[],"path":["dotty","tools","dotc","typer","Checking$","CheckNonCyclicMap","where"],"returnValue":{"title":"String","tpeLink":{"title":"String","target":"scala.String","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"comment":{"body":"<p>A diagnostic output string that indicates the position of the last\n part of a type bounds checked by checkInfo. Possible choices:\n alias, lower bound, upper bound.\n</p>","short":"<p>A diagnostic output string that indicates the position of the last\n part of a type bounds checked by checkInfo.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"val"},{"name":"where_=","modifiers":["<accessor>"],"path":["dotty","tools","dotc","typer","Checking$","CheckNonCyclicMap","where_="],"returnValue":{"title":"Unit","tpeLink":{"title":"Unit","target":"scala.Unit","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"x$1","ref":{"title":"String","tpeLink":{"title":"String","target":"scala.String","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false}],"comment":{"body":"<p>A diagnostic output string that indicates the position of the last\n part of a type bounds checked by checkInfo. Possible choices:\n alias, lower bound, upper bound.\n</p>","short":"<p>A diagnostic output string that indicates the position of the last\n part of a type bounds checked by checkInfo.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"}],"modifiers":[],"path":["tools","dotc","typer","Checking","CheckNonCyclicMap"],"typeParams":[],"constructors":[[{"list":[{"title":"sym","ref":{"title":"Symbol","tpeLink":{"title":"Symbol","query":"Symbol","kind":"UnsetLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"reportErrors","ref":{"title":"Boolean","tpeLink":{"title":"Boolean","query":"Boolean","kind":"UnsetLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","query":"Context","kind":"UnsetLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}]],"superTypes":[{"title":"TypeMap","target":"dotty.tools.dotc.core.Types$.TypeMap","kind":"NoLink"}],"comment":{"body":"<p>A type map which checks that the only cycles in a type are F-bounds\n and that protects all F-bounded references by LazyRefs.\n</p>","short":"<p>A type map which checks that the only cycles in a type are F-bounds\n and that protects all F-bounded references by LazyRefs.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"class"},{"name":"checkAppliedType","modifiers":[],"path":["dotty","tools","dotc","typer","Checking$","checkAppliedType"],"returnValue":{"title":"Unit","tpeLink":{"title":"Unit","target":"scala.Unit","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"tree","ref":{"title":"AppliedTypeTree","tpeLink":{"title":"AppliedTypeTree","target":"scala.AppliedTypeTree","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>Check applied type trees for well-formedness. This means</p><ul><li>all arguments are within their corresponding bounds</li><li>if type is a higher-kinded application with wildcard arguments,\n    check that it or one of its supertypes can be reduced to a normal application.\n    Unreducible applications correspond to general existentials, and we\n    cannot handle those.\n</li></ul>","short":"<p>Check applied type trees for well-formedness.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"checkBounds","modifiers":[],"path":["dotty","tools","dotc","typer","Checking$","checkBounds"],"returnValue":{"title":"Unit","tpeLink":{"title":"Unit","target":"scala.Unit","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"args","ref":{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"Tree","tpeLink":{"title":"Tree","target":"scala.Tree","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"boundss","ref":{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"TypeBounds","tpeLink":{"title":"TypeBounds","target":"scala.TypeBounds","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"instantiate","ref":{"args":[{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"}],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"kind": "FunctionReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>A general checkBounds method that can be used for TypeApply nodes as\n well as for AppliedTypeTree nodes. Also checks that type arguments to\n *-type parameters are fully applied.\n</p>","short":"<p>A general checkBounds method that can be used for TypeApply nodes as\n well as for AppliedTypeTree nodes.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"checkBounds","modifiers":[],"path":["dotty","tools","dotc","typer","Checking$","checkBounds"],"returnValue":{"title":"Unit","tpeLink":{"title":"Unit","target":"scala.Unit","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"args","ref":{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"Tree","tpeLink":{"title":"Tree","target":"scala.Tree","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"poly","ref":{"title":"PolyType","tpeLink":{"title":"PolyType","target":"scala.PolyType","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>Check that type arguments <code>args</code> conform to corresponding bounds in <code>poly</code>\n Note: This does not check the bounds of AppliedTypeTrees. These\n are handled by method checkBounds in FirstTransform\n</p>","short":"<p>Check that type arguments <code>args</code> conform to corresponding bounds in <code>poly</code>\n Note: This does not check the bounds of AppliedTypeTrees.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"checkDerivedValueClass","modifiers":[],"path":["dotty","tools","dotc","typer","Checking$","checkDerivedValueClass"],"returnValue":{"title":"Unit","tpeLink":{"title":"Unit","target":"scala.Unit","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"clazz","ref":{"title":"Symbol","tpeLink":{"title":"Symbol","target":"scala.Symbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"stats","ref":{"title":"List","tpeLink":{"title":"List","target":"scala.collection.immutable.List","kind":"NoLink"},"paramLinks":[{"title":"Tree","tpeLink":{"title":"Tree","target":"scala.Tree","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>Verify classes extending AnyVal meet the requirements</p>","short":"<p>Verify classes extending AnyVal meet the requirements</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"checkInstantiable","modifiers":[],"path":["dotty","tools","dotc","typer","Checking$","checkInstantiable"],"returnValue":{"title":"Unit","tpeLink":{"title":"Unit","target":"scala.Unit","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"tp","ref":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"pos","ref":{"title":"Position","tpeLink":{"title":"Position","target":"scala.Position","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>Check that <code>tp</code> refers to a nonAbstract class\n and that the instance conforms to the self type of the created class.\n</p>","short":"<p>Check that <code>tp</code> refers to a nonAbstract class\n and that the instance conforms to the self type of the created class.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"checkNoPrivateLeaks","modifiers":[],"path":["dotty","tools","dotc","typer","Checking$","checkNoPrivateLeaks"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"sym","ref":{"title":"Symbol","tpeLink":{"title":"Symbol","target":"scala.Symbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"pos","ref":{"title":"Position","tpeLink":{"title":"Position","target":"scala.Position","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>Check the type signature of the symbol <code>M</code> defined by <code>tree</code> does not refer\n to a private type or value which is invisible at a point where <code>M</code> is still\n visible. As an exception, we allow references to type aliases if the underlying\n type of the alias is not a leak. So type aliases are transparent as far as\n leak testing is concerned.</p>","short":"<p>Check the type signature of the symbol <code>M</code> defined by <code>tree</code> does not refer\n to a private type or value which is invisible at a point where <code>M</code> is still\n visible.</p>","authors":[],"see":[],"result":"<p>The <code>info</code> of <code>sym</code>, with problematic aliases expanded away.\n See i997.scala for tests, i1130.scala for a case where it matters that we\n transform leaky aliases away.</p>","throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"checkNonCyclic","modifiers":[],"path":["dotty","tools","dotc","typer","Checking$","checkNonCyclic"],"returnValue":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"sym","ref":{"title":"Symbol","tpeLink":{"title":"Symbol","target":"scala.Symbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"info","ref":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"reportErrors","ref":{"title":"Boolean","tpeLink":{"title":"Boolean","target":"scala.Boolean","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>Check that <code>info</code> of symbol <code>sym</code> is not cyclic.</p>","short":"<p>Check that <code>info</code> of symbol <code>sym</code> is not cyclic.</p>","authors":[],"see":[],"result":"<p><code>info</code> where every legal F-bounded reference is proctected\n                 by a <code>LazyRef</code>, or <code>ErrorType</code> if a cycle was detected and reported.</p>","throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"checkRealizable","modifiers":[],"path":["dotty","tools","dotc","typer","Checking$","checkRealizable"],"returnValue":{"title":"Unit","tpeLink":{"title":"Unit","target":"scala.Unit","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"tp","ref":{"title":"Type","tpeLink":{"title":"Type","target":"scala.Type","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"pos","ref":{"title":"Position","tpeLink":{"title":"Position","target":"scala.Position","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>Check that type <code>tp</code> is realizable.</p>","short":"<p>Check that type <code>tp</code> is realizable.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"checkRefinementNonCyclic","modifiers":[],"path":["dotty","tools","dotc","typer","Checking$","checkRefinementNonCyclic"],"returnValue":{"title":"Unit","tpeLink":{"title":"Unit","target":"scala.Unit","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"refinement","ref":{"title":"Tree","tpeLink":{"title":"Tree","target":"scala.Tree","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"refineCls","ref":{"title":"ClassSymbol","tpeLink":{"title":"ClassSymbol","target":"scala.ClassSymbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"},{"title":"seen","ref":{"title":"Set","tpeLink":{"title":"Set","target":"collection.mutable.Set","kind":"NoLink"},"paramLinks":[{"title":"Symbol","tpeLink":{"title":"Symbol","target":"scala.Symbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"}],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>Check that refinement satisfies the following two conditions</p><ol class=decimal><li>No part of it refers to a symbol that's defined in the same refinement\n    at a textually later point.\n 2. All references to the refinement itself via <code>this</code> are followed by\n    selections.\n Note: It's not yet clear what exactly we want to allow and what we want to rule out.\n This depends also on firming up the DOT calculus. For the moment we only issue\n deprecated warnings, not errors.\n</li></ol>","short":"<p>Check that refinement satisfies the following two conditions</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"},{"name":"checkWellFormed","modifiers":[],"path":["dotty","tools","dotc","typer","Checking$","checkWellFormed"],"returnValue":{"title":"Unit","tpeLink":{"title":"Unit","target":"scala.Unit","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"typeParams":[],"paramLists":[{"list":[{"title":"sym","ref":{"title":"Symbol","tpeLink":{"title":"Symbol","target":"scala.Symbol","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":false},{"list":[{"title":"ctx","ref":{"title":"Context","tpeLink":{"title":"Context","target":"scala.Context","kind":"NoLink"},"paramLinks":[],"kind":"TypeReference"},"isByName":false,"isRepeated":false,"kind":"NamedReference"}],"isImplicit":true}],"comment":{"body":"<p>Check that symbol's definition is well-formed.</p>","short":"<p>Check that symbol's definition is well-formed.</p>","authors":[],"see":[],"throws":{},"valueParams":{},"typeParams":{},"todo":[],"note":[],"example":[],"groupDesc":{},"groupNames":{},"groupPrio":{},"hideImplicitConversions":[]},"kind":"def"}],"modifiers":["final"],"path":["tools","dotc","typer","Checking$"],"superTypes":[],"kind":"object"};
                dotty.tools.doc.client.DottyDoc().main(document.getElementById("main-container"));
            </script>
        </div>
    </body>
</html>
